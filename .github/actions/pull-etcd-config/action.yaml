name: 'Fetch ETCD Config and Create Secret'
description: 'Fetch configuration from an external ETCD instance and create a Kubernetes Secret'

inputs:
  etcd_host:
    description: 'ETCD endpoint'
    required: false
    default: https://config.api.herodotus.cloud:2379
  etcd_user:
    description: 'ETCD username'
    required: true
  etcd_password:
    description: 'ETCD password'
    required: true
  etcd_key:
    description: 'ETCD key to fetch'
    required: true
  namespace:
    description: 'Kubernetes namespace for the Secret'
    required: false
    default: 'default'
  app_name:
    description: 'Application name'
    required: true
  service_account_token:
    description: "Service account token for Kubernetes authentication."
    required: true

outputs:
  secret_changed:
    description: "Whether the secret content has changed"
    value: ${{ steps.check_secret_change.outputs.changed }}
  secret_hash:
    description: "Hash of the secret content"
    value: ${{ steps.compute_hash.outputs.hash }}

runs:
  using: "composite"
  steps:
    - name: Pull and Run Secret Preparation Container
      run: |
        docker run --rm \
          -e ETCD_HOST="etcd.etcd.svc.cluster.local:2379" \
          -e ETCD_USER="${{ inputs.ETCD_USER }}" \
          -e ETCD_PASSWORD="${{ inputs.ETCD_PASSWORD }}" \
          -e ETCD_KEY="${{ inputs.namespace }}/${{ inputs.app_name }}/envs/${{ inputs.ETCD_KEY }}" \
          -e APP_NAME="${{ inputs.app_name }}" \
          -e NAMESPACE="${{ inputs.namespace }}" \
          -v ${{ github.workspace }}/output:/output \
          dataprocessor/etcd-pull:0.2
      shell: bash

    - name: Change Ownership of Output Files
      run: sudo chown -R $(whoami):$(whoami) ${{ github.workspace }}/output
      shell: bash

    - name: Set up kubectl
      uses: azure/setup-kubectl@v4
      with:
        version: "v1.32.0"

    - name: Compute Secret Hash
      id: compute_hash
      shell: bash
      run: |
        HASH=$(sha256sum "${{ github.workspace }}/output/secret.yaml" | awk '{print $1}')
        echo "hash=$HASH" >> $GITHUB_OUTPUT

    - name: Check Previous Secret Hash
      id: check_secret_change
      shell: bash
      run: |
        # Check if secret exists
        if kubectl get secret ${{ inputs.app_name }}-config -n ${{ inputs.namespace }} &>/dev/null; then
          # Secret exists, get its hash annotation
          CURRENT_HASH=$(kubectl get secret ${{ inputs.app_name }}-config -n ${{ inputs.namespace }} -o jsonpath='{.metadata.annotations.secret-hash}' 2>/dev/null || echo "")
          if [ -z "$CURRENT_HASH" ]; then
            # Secret exists but no hash annotation - treat as changed
            echo "Secret exists but has no hash annotation - marking as changed"
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            # Compare hashes
            NEW_HASH="${{ steps.compute_hash.outputs.hash }}"
            if [ "$CURRENT_HASH" != "$NEW_HASH" ]; then
              echo "Secret hash changed from $CURRENT_HASH to $NEW_HASH"
              echo "changed=true" >> $GITHUB_OUTPUT
            else
              echo "Secret hash unchanged"
              echo "changed=false" >> $GITHUB_OUTPUT
            fi
          fi
        else
          # Secret doesn't exist - treat as changed
          echo "Secret doesn't exist - marking as changed"
          echo "changed=true" >> $GITHUB_OUTPUT
        fi

    - name: Add Hash Annotation to Secret
      shell: bash
      run: |
        # Add hash annotation to the secret yaml
        sed -i "/metadata:/a\\  annotations:\\n    secret-hash: ${{ steps.compute_hash.outputs.hash }}" ${{ github.workspace }}/output/secret.yaml

    - name: Apply Kubernetes Secret
      run: kubectl apply -f ${{ github.workspace }}/output/secret.yaml            
      shell: bash
