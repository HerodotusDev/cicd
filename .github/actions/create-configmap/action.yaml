name: 'Create/Update ConfigMap from Files'
description: 'Create or update a Kubernetes ConfigMap from a files directory, annotate with a content hash, and report change status.'

inputs:
  namespace:
    description: 'Kubernetes namespace for the ConfigMap'
    required: true
  app_name:
    description: 'Application name (used to form ConfigMap name)'
    required: true
  k8s_env:
    description: 'Kubernetes environment (used to locate files)'
    required: true

outputs:
  config_changed:
    description: 'Whether the ConfigMap content has changed'
    value: ${{ steps.check_cm_change.outputs.changed }}
  configmap_hash:
    description: 'Hash of the ConfigMap content'
    value: ${{ steps.compute_hash.outputs.hash }}

runs:
  using: 'composite'
  steps:
    - name: Detect ConfigMap files directory
      id: detect
      shell: bash
      run: |
        set -euo pipefail
        CONFIGMAP_DIR="./k8s/${{ inputs.k8s_env }}/${{ inputs.app_name }}-configmap"
        if [ -d "$CONFIGMAP_DIR" ] && [ "$(ls -A "$CONFIGMAP_DIR")" ]; then
          echo "has_files=true" >> "$GITHUB_OUTPUT"
          echo "dir=$CONFIGMAP_DIR" >> "$GITHUB_OUTPUT"
        else
          echo "No files in $CONFIGMAP_DIR, skipping ConfigMap creation."
          echo "has_files=false" >> "$GITHUB_OUTPUT"
          echo "dir=$CONFIGMAP_DIR" >> "$GITHUB_OUTPUT"
        fi

    - name: Set up kubectl
      if: steps.detect.outputs.has_files == 'true'
      uses: azure/setup-kubectl@v4
      with:
        version: 'v1.32.0'

    - name: Compute ConfigMap content hash
      id: compute_hash
      if: steps.detect.outputs.has_files == 'true'
      shell: bash
      run: |
        set -euo pipefail
        dir="${{ steps.detect.outputs.dir }}"
        # Hash files deterministically by name and content
        HASH=$(find "$dir" -type f -print0 | sort -z | xargs -0 sha256sum | sha256sum | awk '{print $1}')
        echo "hash=$HASH" >> "$GITHUB_OUTPUT"

    - name: Default hash when no files
      id: compute_hash
      if: steps.detect.outputs.has_files == 'false'
      shell: bash
      run: echo "hash=" >> "$GITHUB_OUTPUT"

    - name: Check previous ConfigMap hash
      id: check_cm_change
      if: steps.detect.outputs.has_files == 'true'
      shell: bash
      run: |
        set -euo pipefail
        CM_NAME="${{ inputs.app_name }}-configmap"
        NS="${{ inputs.namespace }}"
        if kubectl get configmap "$CM_NAME" -n "$NS" &>/dev/null; then
          CURRENT_HASH=$(kubectl get configmap "$CM_NAME" -n "$NS" -o jsonpath='{.metadata.annotations.configmap-hash}' 2>/dev/null || echo "")
          if [ -z "$CURRENT_HASH" ]; then
            echo "ConfigMap exists but has no hash annotation - marking as changed"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            NEW_HASH="${{ steps.compute_hash.outputs.hash }}"
            if [ "$CURRENT_HASH" != "$NEW_HASH" ]; then
              echo "ConfigMap hash changed from $CURRENT_HASH to $NEW_HASH"
              echo "changed=true" >> "$GITHUB_OUTPUT"
            else
              echo "ConfigMap hash unchanged"
              echo "changed=false" >> "$GITHUB_OUTPUT"
            fi
          fi
        else
          echo "ConfigMap doesn't exist - marking as changed"
          echo "changed=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Default change flag when no files
      id: check_cm_change
      if: steps.detect.outputs.has_files == 'false'
      shell: bash
      run: echo "changed=false" >> "$GITHUB_OUTPUT"

    - name: Generate ConfigMap manifest with files
      if: steps.detect.outputs.has_files == 'true'
      shell: bash
      run: |
        set -euo pipefail
        CM_NAME="${{ inputs.app_name }}-configmap"
        NS="${{ inputs.namespace }}"
        dir="${{ steps.detect.outputs.dir }}"
        mkdir -p "${{ github.workspace }}/output"
        # Build manifest deterministically with filenames as keys
        kubectl create configmap "$CM_NAME" \
          --namespace "$NS" \
          $(for f in "$dir"/*; do bn=$(basename "$f"); echo --from-file="$bn=$f"; done) \
          --dry-run=client -o yaml > "${{ github.workspace }}/output/configmap.yaml"

    - name: Annotate ConfigMap manifest with hash
      if: steps.detect.outputs.has_files == 'true'
      shell: bash
      run: |
        set -euo pipefail
        sed -i "/metadata:/a\\  annotations:\\n    configmap-hash: ${{ steps.compute_hash.outputs.hash }}" "${{ github.workspace }}/output/configmap.yaml"

    - name: Apply ConfigMap
      if: steps.detect.outputs.has_files == 'true'
      shell: bash
      run: kubectl apply -f "${{ github.workspace }}/output/configmap.yaml"
